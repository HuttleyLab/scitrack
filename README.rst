##################
About ``scitrack``
##################

One of the critical challenges in scientific analysis is to track all the elements involved. This includes the arguments provided to a specific application, input data files referenced by those arguments and output data generated by the application. In addition to this, tracking a minimal set of system specific information.

``scitrack`` is a library aimed at application developers writing scientific software to support this track of scientific computation.  The library provides elementary functionality to support logging. The primary capabilities concern generating checksums on input and output files and facilitating logging of the computational environment. If the optional dependency ``mpiutils`` is installed, then logging can be done safely in a parallel computation environment.

**********
Installing
**********

Until it's up on pypi, the following command will work::

    $ pip install hg+ssh://hg@bitbucket.org/gavin.huttley/scitrack

Or clone it::

    $ hg clone ssh://hg@bitbucket.org/gavin.huttley/scitrack

And then install::

    $ pip install ~/path/to/scitrack

*****************
``CachingLogger``
*****************

There is a single object provided by ``scitrack``, ``CachingLogger``. This object is basically a wrapper around the ``logging`` module, but on invocation, captures basic information regarding the system and the command line call that was made to invoke the application.

In addition, the class provides convenience methods for logging both the path and the md5 hexdigest checksum of input/output files. A method is also provided for producing checksums of text data. The latter is useful for the case when data are from a stream or a database, for instance.

All logging calls are cached until a path for a logfile is provided. The logger can also, optionally, create directories.

When run in parallel using ``mpirun``, the process ID is appended to the hostname to help identify processors.

**********************************
Simple instantiation of the logger
**********************************

Creating the logger. Setting ``create_dir=True`` means on creation of the logfile, the directory path will be created also.::

    >>> from scitrack import CachingLogger
    >>> LOGGER = CachingLogger(create_dir=True)
    >>> LOGGER.log_file_path = "somedir/some_path.log"

The last assignment triggers creation of ``somedir/some_path.log``.

******************************************
Capturing a programs arguments and options
******************************************

``scitrack`` will write the contents of ``sys.argv`` to the log file, prefixed by ``command_string``. However, this only captures arguments specified on the command line. Tracking the value of optional arguments not specified, which may have default values, is critical to tracking the full command set. Doing this is your responsibility as a developer.

Here's one approach when using the ``click`` `command line interface library <http://click.pocoo.org/>`_. Below we create a simple ``click`` app and capture the required and optional argument values.::

    >>> from scitrack import CachingLogger
    >>> import click
    >>>
    >>> LOGGER = CachingLogger()
    >>>
    >>> class Config(object):
    ...     def __init__(self):
    ...         super(Config, self).__init__()
    ...
    >>> pass_config = click.make_pass_decorator(Config, ensure=True)
    >>>
    >>> @click.group()
    >>> @click.option('--foo', help='Text arg.')
    >>> @pass_config
    >>> def main(cfg_context, foo):
    ...     cfg_context.foo = foo
    ...
    >>> @main.command()
    >>> @click.option('--infile', type=click.File('rb'))
    >>> @click.option('--test', is_flag=True, help='Run test.')
    >>> @pass_config
    >>> def my_app(cfg_context, infile, test):
    ...     cfg_context.infile = infile.name
    ...     cfg_context.test = test
    ...
    ...     args = vars(cfg_context)
    ...     LOGGER.log_message(str(args), label='vars')
    ...     LOGGER.input_file(infile.name)
    ...     LOGGER.log_file_path = "some_path.log"
    ...
    >>>

The ``CachingLogger.write()`` method takes a message and a label. All other logging methods wrap ``log_message()``, providing a specific label. For instance, the method ``input_file()`` writes out two lines in the log.

    - input_file_path, the absolute path to the intput file
    - input_file_path md5sum, the hex digest of the file

``output_file()`` behaves analogously. An additional method ``text_data()`` is useful for other data input/output sources (e.g. records from a database). For this to have value for arbitrary data types requires a systematic approach to ensuring the text conversion is robust across platforms.

Some sample output
==================

::

    2016-05-22 11:37:17	Thales.local:6095	INFO	system_details : system=Darwin Kernel Version 15.5.0: Tue Apr 19 18:36:36 PDT 2016; root:xnu-3248.50.21~8/RELEASE_X86_64
    2016-05-22 11:37:17	Thales.local:6095	INFO	python : 2.7.10
    2016-05-22 11:37:17	Thales.local:6095	INFO	user : gavin
    2016-05-22 11:37:17	Thales.local:6095	INFO	command_string : /Users/gavin/.virtualenvs/delme/bin/nosetests
    2016-05-22 11:37:17	Thales.local:6095	INFO	input_file_path : /Users/gavin/DevRepos/SciTrack/tests/sample.fasta
    2016-05-22 11:37:17	Thales.local:6095	INFO	input_file_path md5sum : 96eb2c2632bae19eb65ea9224aaafdad


**********************
Other useful functions
**********************

Two other useful functions are ``get_file_hexdigest`` and ``get_text_hexdigest``. The latter can take either unicode or ascii strings.
